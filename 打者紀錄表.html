<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>æ‰“è€…æˆç¸¾æŸ¥è©¢</title>
  <style>
    body { font-family: system-ui, "Noto Sans TC", Arial; margin: 24px; background-color: #f0f2f5; }
    .container { max-width: 1200px; margin: 0 auto; padding: 20px; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    h1 { margin: 0 0 16px; font-size: 28px; color: #333; }
    .note-readonly {
      background-color: #fff3cd;
      color: #856404;
      border: 1px solid #ffeeba;
      padding: 12px 16px;
      margin-bottom: 16px;
      border-radius: 4px;
      font-size: 14px;
    }
    .controls { display: flex; gap: 12px; flex-wrap: wrap; margin-bottom: 16px; }
    input, select, button { padding: 10px 12px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px; }
    button { background-color: #f0f0f0; cursor: pointer; }
    button:hover { background-color: #e0e0e0; }
    .table-wrapper { overflow: auto; max-height: 65vh; border-top: 1px solid #eee; }
    table { width: 100%; border-collapse: collapse; font-size: 14px; }
    th, td { padding: 10px 12px; border-bottom: 1px solid #ddd; text-align: center; white-space: nowrap; }
    /* Combined thead rules for clarity. */
    thead { position: sticky; top: 0; z-index: 2; background: #f9f9f9; }
    th { background: #f9f9f9; }
    thead.is-sticky {
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: box-shadow 0.2s ease-in-out;
    }

    th:nth-child(1), td:nth-child(1) {
      position: sticky;
      left: 0;
      z-index: 1;
      border-right: 1px solid #ddd;
    }

    th:nth-child(2), td:nth-child(2) {
      position: sticky;
      z-index: 1;
      border-right: 1px solid #ddd;
      /* 'left' is set by JS */
    }

    th:nth-child(3), td:nth-child(3) {
      position: sticky;
      z-index: 1;
      border-right: 1px solid #ddd;
      /* 'left' is set by JS */
    }

    /* Set backgrounds for sticky columns */
    td:nth-child(1), td:nth-child(2), td:nth-child(3) { background-color: #fff; }
    thead th:nth-child(1), thead th:nth-child(2), thead th:nth-child(3) { background-color: #f9f9f9; z-index: 3; }

    .career-view-table {
      background-color: #e6f7ff; /* Light blue for career view */
    }

    @media (max-width: 768px) {
      body { margin: 0; background-color: #fff; }
      .container { padding: 15px; border-radius: 0; box-shadow: none; }
      h1 { font-size: 22px; }
      .controls { flex-direction: column; }
      input, select, button { width: 100%; box-sizing: border-box; }
    }
  </style>
</head>
<body>



<div class="container">
  <h1>å°ä¸­å¸‚ CBL ä¼æ¥­äº¤æµè¯ç›Ÿ æ‰“è€…æˆç¸¾æŸ¥è©¢</h1>


  <p style="font-size: 14px; color: #666; margin-bottom: 16px;">æˆç¸¾æ›´æ–°æ™‚é–“ï¼š<span id="last-updated">è®€å–ä¸­...</span></p>

  <div class="note-readonly">
    âš ï¸ æç¤ºï¼šæ­¤é é¢åƒ…ä¾›æŸ¥è©¢çƒå“¡æˆç¸¾ï¼Œä½¿ç”¨è€…ç„¡æ³•ä¿®æ”¹è³‡æ–™ã€‚
  </div>

  <div class="controls">
    <input id="search" type="text" placeholder="æœå°‹ï¼šçƒå“¡å§“å" />
    <select id="team"><option value="">å…¨éƒ¨çƒéšŠ</option></select>
    <select id="season"><option value="">å…¨éƒ¨å±†æ•¸</option></select>
    <button id="toggle-career-view">æŸ¥çœ‹ç”Ÿæ¶¯æˆç¸¾</button>
  </div>

  <div class="table-wrapper">
    <table id="table">
      <thead><tr id="header-row"></tr></thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>
</div>

  <script>
    // ğŸ‘‡ åœ¨é€™è£¡è²¼ä¸Š Google è©¦ç®—è¡¨ã€Œç™¼ä½ˆåˆ°ç¶²è·¯ã€çš„ CSV é€£çµ
    const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vT_X5jYPR24dk5oqUSr1py8glTu-jHZJwuzhyJN7RrjMkgkXjwv0hVgmn7KlieQy_-CZEn6UQofqTbz/pub?gid=546432089&single=true&output=csv";

    const searchInput = document.getElementById('search');
    const teamSelect = document.getElementById('team');
    const seasonSelect = document.getElementById('season');
    const headerRow = document.getElementById('header-row');
    const tbody = document.getElementById('tbody');
    const careerViewBtn = document.getElementById('toggle-career-view');
    
    let originalRows = [], careerStats = [], headers = [];
    let isCareerView = false;
    let sortKey = '', sortOrder = 'none';

    // --- ä¸»è¦è³‡æ–™è™•ç†æµç¨‹ ---
    async function main() {
      try {
        const text = await fetchCSV(CSV_URL);
        parseCSV(text); // -> populates headers and originalRows
        
        console.log('è¨ºæ–·ï¼šHeaders:', headers);
        console.log('è¨ºæ–·ï¼šOriginal Rows (first 5):', originalRows.slice(0, 5));
        
        // å¾è¡¨é ­ AC1 æ¬„ä½æå–æ›´æ–°æ™‚é–“
        extractAndUpdateTime();
        
        // æº–å‚™ç”Ÿæ¶¯æ•¸æ“š
        calculateCareerStats();
        
        buildFilters();
        setupEventListeners();
        render();
        
      } catch (err) {
        tbody.innerHTML = `<tr><td colspan="10">${err.message}</td></tr>`;
        console.error('è¨ºæ–·ï¼šmain å‡½å¼åŸ·è¡ŒéŒ¯èª¤:', err);
      }
    }

    async function fetchCSV(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`è®€å–å¤±æ•—ï¼šHTTP ${res.status}`);
      return res.text();
    }

    function parseCSV(text) {
      const lines = text.replace(/\r/g,'').split('\n').filter(l => l.trim() !== '');
      headers = splitCSVLine(lines[0]).map(h => h.trim());
      originalRows = lines.slice(1).map(line => {
        const cells = splitCSVLine(line);
        const obj = {};
        headers.forEach((h, i) => obj[h] = (cells[i] || '').trim());
        return obj;
      });
    }
    
    function calculateCareerStats() {
      const nameKey = headers.find(h => h.includes('å§“å')) || "èƒŒè™Ÿ/å§“å";
      const teamKey = headers.find(h => h.includes('éšŠ')) || "éšŠä¼";
      const seasonKey = headers.find(h => h.includes('å±†æ•¸') || h.includes('å±†åˆ¥') || h.includes('è³½å­£')) || "å±†æ•¸";
      const nonStatKeys = [nameKey, teamKey, seasonKey]; // ç´¯è¨ˆæ™‚éœ€å¿½ç•¥çš„éµ

      const playerStats = new Map();

      for (const row of originalRows) {
        const playerName = row[nameKey] ? row[nameKey].trim() : null;
        if (!playerName) continue;

        if (!playerStats.has(playerName)) {
          // é¦–æ¬¡é‡åˆ°çƒå“¡ï¼šç›´æ¥ç”¨ç¬¬ä¸€ç­†è³‡æ–™å»ºç«‹ç´€éŒ„
          const newStats = {
            [nameKey]: playerName,
            [teamKey]: row[teamKey], 
            [seasonKey]: 'ç”Ÿæ¶¯',
            lastSeason: row[seasonKey],
          };
          for (const h of headers) {
            if (!nonStatKeys.includes(h)) {
              newStats[h] = (Number(row[h]) || 0);
            }
          }
          playerStats.set(playerName, newStats);
        } else {
          // å¾ŒçºŒé‡åˆ°çƒå“¡ï¼šç´¯åŠ æ•¸æ“š
          const stats = playerStats.get(playerName);
          
          if (row[seasonKey] > stats.lastSeason) {
            stats.lastSeason = row[seasonKey];
            stats[teamKey] = row[teamKey];
          }

          for (const h of headers) {
            if (!nonStatKeys.includes(h)) {
              stats[h] += (Number(row[h]) || 0);
            }
          }
        }
      }

      // --- å‹•æ…‹å°‹æ‰¾è¨ˆç®—æ¯”ç‡æ‰€éœ€çš„æ¬„ä½éµ ---
      const ABKey = headers.find(h => h === 'AB' || h === 'æ‰“æ•¸') || 'AB';
      const HKey = headers.find(h => h === 'H' || h === 'å®‰æ‰“ç¸½æ•¸' || h === 'å®‰æ‰“') || 'H';
      const BBKey = headers.find(h => h.toUpperCase() === 'BB' || h === 'å››å£') || 'BB';
      const HBPKey = headers.find(h => h.toUpperCase() === 'HBP' || h === 'è§¸èº«') || 'HBP';
      const SFKey = headers.find(h => h.toUpperCase() === 'SF' || h === 'é«˜çŠ§') || 'SF'; // é‡æ–°å¼•å…¥ SFKey
      const PAKey = headers.find(h => h.toUpperCase() === 'PA' || h === 'æ‰“å¸­') || 'PA'; // PAKey ä»ä¿ç•™ï¼Œä»¥é˜²å…¶ä»–è¨ˆç®—éœ€è¦
      const TBKey = headers.find(h => h === 'TB' || h === 'å£˜æ‰“æ•¸') || 'TB';
      const GOKey = headers.find(h => h === 'GO' || h === 'æ»¾åœ°') || 'GO';
      const AOKey = headers.find(h => h === 'AO' || h === 'é£›çƒ') || 'AO';
      const soKey = headers.find(h => h.toUpperCase() === 'SO' || h === 'ä¸‰æŒ¯') || 'SO';
      
      const avgKey = headers.find(h => h.includes('AVG') || h.includes('æ‰“æ“Šç‡')) || 'AVG';
      const obpKey = headers.find(h => h.includes('OBP') || h.includes('ä¸Šå£˜ç‡')) || 'OBP';
      const slgKey = headers.find(h => h.includes('SLG') || h.includes('é•·æ‰“ç‡')) || 'SLG';
      const opsKey = headers.find(h => h.includes('OPS')) || 'OPS';
      const goaoKey = headers.find(h => h.includes('GO/AO')) || 'GO/AO';
      const kRateKey = headers.find(h => h.toUpperCase() === 'K%' || h === 'ä¸‰æŒ¯ç‡' || h === 'è¢«ä¸‰æŒ¯ç‡') || 'è¢«ä¸‰æŒ¯ç‡';

            // --- é‡æ–°è¨ˆç®—ä¸¦å¼·åˆ¶è¦†è“‹æ¯”ç‡æ•¸æ“š ---
            careerStats = Array.from(playerStats.values()).map(stats => {
        const AB = stats[ABKey] || 0;
        const H = stats[HKey] || 0;
        const BB = stats[BBKey] || 0;
        const HBP = stats[HBPKey] || 0;
        const SF = stats[SFKey] || 0; // é‡æ–°å–å¾— SF
        const PA = stats[PAKey] || 0; // é›–ç„¶ OBP ä¸ç”¨ï¼Œä½†å¯èƒ½å…¶ä»–åœ°æ–¹æœƒç”¨åˆ°
        const TB = stats[TBKey] || 0;
        const SO = stats[soKey] || 0;



        stats[avgKey] = AB > 0 ? (H / AB).toFixed(3) : '.000';
        // æ”¹å›æ¨™æº– OBP è¨ˆç®—å…¬å¼
        stats[obpKey] = (AB + BB + HBP + SF) > 0 ? ((H + BB + HBP) / (AB + BB + HBP + SF)).toFixed(3) : '.000';
        stats[slgKey] = AB > 0 ? (TB / AB).toFixed(3) : '.000';
        stats[opsKey] = (parseFloat(stats[obpKey]) + parseFloat(stats[slgKey])).toFixed(3);
        
        const GO = stats[GOKey] || 0;
        const AO = stats[AOKey] || 0;
        if (headers.includes(goaoKey)) {
           stats[goaoKey] = AO > 0 ? (GO/AO).toFixed(2) : '0.00';
        }


        if (headers.includes(kRateKey)) {
            const originalKRate = stats[kRateKey];
            stats[kRateKey] = PA > 0 ? ( (SO / PA) * 100 ).toFixed(1) + '%' : '0.0%';

        }
        
        return stats;
      });
    }

    function render() {
      const dataToRender = isCareerView ? careerStats : originalRows;
      
      // 1. éæ¿¾
      const nameKey = searchInput.dataset.nameKey;
      const teamKey = teamSelect.dataset.teamKey;
      const seasonKey = seasonSelect.dataset.seasonKey;
      
      const kw = searchInput.value.trim().toLowerCase();
      const team = teamSelect.value;
      const season = seasonSelect.value;
      
      const filtered = dataToRender.filter(r => {
        const passName = kw ? String(r[nameKey] || '').toLowerCase().includes(kw) : true;
        const passTeam = team ? r[teamKey] === team : true;
        // ç”Ÿæ¶¯æ¨¡å¼ä¸‹ä¸çœ‹è³½å­£éæ¿¾
        const passSeason = isCareerView ? true : (season ? (r[seasonKey] === season || (console.log(`è¨ºæ–·ï¼šComparing selected season "${season}" with row season "${r[seasonKey]}"`) && false)) : true);
        return passName && passTeam && passSeason;
      });

      // 2. æ’åº
      if (sortKey && sortOrder !== 'none') {
        const isNumeric = !['AVG', 'OBP', 'SLG', 'OPS', 'GO/AO'].includes(sortKey) && headers.includes(sortKey);
        
        filtered.sort((a, b) => {
          const valA = isNumeric ? Number(a[sortKey] || 0) : parseFloat(a[sortKey] || 0);
          const valB = isNumeric ? Number(b[sortKey] || 0) : parseFloat(b[sortKey] || 0);
          
          if (isNaN(valA)) return 1;
          if (isNaN(valB)) return -1;
          
          return sortOrder === 'asc' ? valA - valB : valB - valA;
        });
      }

      // 3. æ¸²æŸ“è¡¨é ­å’Œå…§å®¹
      renderHeaders();
      renderBody(filtered);
      
      updateStickyColumns();
    }
    
    function renderHeaders() {
      const AC1_COLUMN_INDEX = 28; // AC1 ç‚ºæ›´æ–°æ™‚é–“ï¼Œä¸é¡¯ç¤º
      // åœ¨ç”Ÿæ¶¯æ¨¡å¼ä¸‹ï¼Œéš±è—è³½å­£æ¬„ä½
      const seasonKey = headers.find(h => h.includes('å±†åˆ¥') || h.includes('è³½å­£'));
      
      window.displayHeaders = headers.filter((h, index) => {
        if (index === AC1_COLUMN_INDEX) return false;
        if (isCareerView && h === seasonKey) return false;
        return true;
      });

      headerRow.innerHTML = window.displayHeaders.map(h => {
        const isSortable = originalRows.length > 0 && (Number(originalRows[0][h]) > 0 || ['AVG', 'OBP', 'SLG', 'OPS'].includes(h));
        if (!isSortable) return `<th>${h}</th>`;
        
        let sortIndicator = '&#9670;'; // lozenge
        if (sortKey === h) {
          if (sortOrder === 'asc') sortIndicator = '&#9650;'; // up
          if (sortOrder === 'desc') sortIndicator = '&#9660;'; // down
        }
        return `<th>${h} <span class="sort-toggle" data-key="${h}" style="cursor: pointer;">${sortIndicator}</span></th>`;
      }).join('');
    }

    function renderBody(data) {
       tbody.innerHTML = data.map(r => `<tr>` + window.displayHeaders.map(h => `<td>${r[h] ?? ''}</td>`).join('') + `</tr>`).join('')
        || `<tr><td colspan="${(window.displayHeaders || []).length}">æ‰¾ä¸åˆ°ç¬¦åˆçš„è³‡æ–™</td></tr>`;
    }

    // --- äº‹ä»¶ç›£è½èˆ‡è¨­å®š ---
    function setupEventListeners() {
      // ç¯©é¸å™¨
      searchInput.addEventListener('input', render); // æœå°‹æ¡†ä½¿ç”¨ input äº‹ä»¶
      [teamSelect, seasonSelect].forEach(el => el.addEventListener('change', render)); // ä¸‹æ‹‰é¸å–®ä½¿ç”¨ change äº‹ä»¶
      
      // ç”Ÿæ¶¯/è³½å­£åˆ‡æ›
      careerViewBtn.addEventListener('click', () => {
        isCareerView = !isCareerView;
        careerViewBtn.textContent = isCareerView ? 'è¿”å›è³½å­£æˆç¸¾' : 'æŸ¥çœ‹ç”Ÿæ¶¯æˆç¸¾';
        seasonSelect.disabled = isCareerView;
        
        // åˆ‡æ›è¡¨æ ¼é¡è‰²
        document.getElementById('table').classList.toggle('career-view-table', isCareerView);

        // åˆ‡æ›æ™‚é‡è¨­æ’åº
        sortKey = '';
        sortOrder = 'none';
        render();
      });

      // è¡¨é ­æ’åº
      headerRow.addEventListener('click', e => {
        const target = e.target.closest('.sort-toggle');
        if (!target) return;
        
        const key = target.dataset.key;
        if (sortKey === key) {
          sortOrder = sortOrder === 'desc' ? 'asc' : 'desc';
        } else {
          sortKey = key;
          sortOrder = 'desc'; // é è¨­é™åº
        }
        render();
      });


      

      window.addEventListener('resize', updateStickyColumns);
      
      // Sticky header é™°å½±
      try {
        const thead = document.querySelector('#table thead');
        if (thead) {
          new IntersectionObserver(([e]) => thead.classList.toggle('is-sticky', e.intersectionRatio < 1), { threshold: [1] }).observe(thead);
        }
      } catch (e) {
        console.error('è¨ºæ–·ï¼šSticky header observer failed:', e);
      }
    }

    function buildFilters() {
      const teamKey = headers.find(h => h.includes('éšŠ')) || "éšŠä¼";
      const seasonKey = headers.find(h => h.includes('å±†æ•¸') || h.includes('å±†åˆ¥') || h.includes('è³½å­£')) || "å±†æ•¸";
      const nameKey = headers.find(h => h.includes('å§“å')) || "èƒŒè™Ÿ/å§“å";

      const teams = [...new Set(originalRows.map(r => r[teamKey]).filter(Boolean))].sort();
      const seasons = [...new Set(originalRows.map(r => r[seasonKey]).filter(Boolean))].sort().reverse();
      
      console.log('è¨ºæ–·ï¼šDetermined seasonKey:', seasonKey);
      console.log('è¨ºæ–·ï¼šExtracted Seasons:', seasons);
      
      teamSelect.innerHTML = '<option value="">å…¨éƒ¨çƒéšŠ</option>' + teams.map(t => `<option>${t}</option>`).join('');
      seasonSelect.innerHTML = '<option value="">å…¨éƒ¨å±†æ•¸</option>' + seasons.map(s => `<option>${s}</option>`).join('');
      
      // é è¨­é¡¯ç¤ºç¬¬äºŒå±†
      seasonSelect.value = 'ç¬¬äºŒå±†';
      console.log('è¨ºæ–·ï¼šSeason Select HTML:', seasonSelect.innerHTML);
      console.log('è¨ºæ–·ï¼šSeason Select Value after setting default:', seasonSelect.value);
      console.log('è¨ºæ–·ï¼šSeason Select Options:', Array.from(seasonSelect.options).map(opt => opt.value));

      searchInput.dataset.nameKey = nameKey;
      teamSelect.dataset.teamKey = teamKey;
      seasonSelect.dataset.seasonKey = seasonKey;
    }

    function extractAndUpdateTime() {
      const AC1_COLUMN_INDEX = 28;
      const updateTimeElement = document.getElementById('last-updated');
      if (!updateTimeElement) return;

      if (headers.length > AC1_COLUMN_INDEX) {
        const updateTimeFromAC1 = headers[AC1_COLUMN_INDEX];
        updateTimeElement.textContent = updateTimeFromAC1 || 'ç„¡æ³•å–å¾—æ›´æ–°æ™‚é–“';
      } else {
        updateTimeElement.textContent = 'CSVè³‡æ–™ä¸è¶³';
      }
    }


    function updateStickyColumns() {
      const firstCol = document.querySelector('#table th:nth-child(1)');
      const secondCol = document.querySelector('#table th:nth-child(2)');
      if (!firstCol || !secondCol) return;
      
      const firstColWidth = firstCol.offsetWidth;
      const secondColWidth = secondCol.offsetWidth;

      const secondColElems = document.querySelectorAll('#table th:nth-child(2), #table td:nth-child(2)');
      secondColElems.forEach(elem => {
        elem.style.left = firstColWidth + 'px';
      });

      const thirdColElems = document.querySelectorAll('#table th:nth-child(3), #table td:nth-child(3)');
      thirdColElems.forEach(elem => {
        elem.style.left = (firstColWidth + secondColWidth) + 'px';
      });
    }

    // --- å·¥å…·å‡½æ•¸ ---
    function splitCSVLine(line) {
      const out = []; let cur = '', inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const c = line[i], n = line[i+1];
        if (c === '"' && inQuotes && n === '"') { cur += '"'; i++; }
        else if (c === '"') { inQuotes = !inQuotes; }
        else if (c === ',' && !inQuotes) { out.push(cur); cur = ''; }
        else { cur += c; }
      }
      out.push(cur);
      return out;
    }
    

    // --- å•Ÿå‹• ---
    main();
  </script>

</body>
</html>