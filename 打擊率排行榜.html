<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰“æ“Šæ’è¡Œæ¦œ</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #dddddd;
            text-align: left;
            padding: 8px;
        }
        th {
            background-color: #f2f2f2;
        }

        @media screen and (max-width: 600px) {
            .table-container {
                overflow-x: auto;
            }
            body {
                font-size: 0.9em;
            }
            th, td {
                padding: 6px;
            }
        }
    </style>
</head>
<body>

    <h1>æ‰“æ“Šæ’è¡Œæ¦œ <span style="font-size: 0.5em;">(ç•¶å±†å­£è³½ç¸½å ´æ•¸*1.9=å…¥é¸æ‰“å¸­æ•¸ï¼Œå¦‚æœæˆç¸¾ä¸€æ¨£ä¾ç…§æ‰“å¸­æ•¸å¤šè€…æ’åè¼ƒå‰)</span></h1>

    <div class="table-container">
        <table>
        <thead>
            <tr>
                <th>æ’å</th>
                <th>çƒå“¡</th>
                <th>éšŠä¼</th>
                <th>æ‰“æ“Šç‡</th>
            </tr>
        </thead>
        <tbody id="leaderboard-tbody">
            <!-- Data will be loaded dynamically -->
        </tbody>
    </table>
    </div>

    <script>
        const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vT_X5jYPR24dk5oqUSr1py8glTu-jHZJwuzhyJN7RrjMkgkXjwv0hVgmn7KlieQy_-CZEn6UQofqTbz/pub?gid=546432089&single=true&output=csv";
        const tbody = document.getElementById('leaderboard-tbody');

        async function fetchAndRenderLeaderboard() {
            try {
                const res = await fetch(CSV_URL);
                if (!res.ok) throw new Error('Failed to fetch CSV: HTTP ' + res.status);
                const text = await res.text();
                
                const lines = text.trim().split(/\n/);
                const headers = lines[0].split(',').map(h => h.trim());
                let data = lines.slice(1).map(line => {
                    const values = [];
                    let current_value = "";
                    let in_quotes = false;
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        const next_char = line[i+1];
                        if (char === '"' && in_quotes && next_char === '"' ) {
                            current_value += '"' ;
                            i++;
                        } else if (char === '"' ) {
                            in_quotes = !in_quotes;
                        } else if (char === ',' && !in_quotes) {
                            values.push(current_value.trim());
                            current_value = "";
                        } else {
                            current_value += char;
                        }
                    }
                    values.push(current_value.trim());

                    const row_data = {};
                    headers.forEach((h, i) => row_data[h] = values[i] || "");
                    return row_data;
                });

                const seasonKey = headers.find(h => h.includes('å±†æ•¸') || h.includes('å±†åˆ¥') || h.includes('è³½å­£')) || "å±†æ•¸";
                data = data.filter(row => row[seasonKey] === 'ç¬¬äºŒå±†');

                const player_key = headers.find(h => h.includes('å§“å')) || 'èƒŒè™Ÿ/å§“å';
                const team_key = headers.find(h => h.includes('éšŠä¼')) || 'éšŠä¼';
                const batting_avg_key = headers.find(h => h.includes('æ‰“æ“Šç‡')) || 'æ‰“æ“Šç‡';
                const pa_key = headers.find(h => h.includes('æ‰“å¸­')) || 'æ‰“å¸­';

                const filtered_data = [];
                for (const entry of data) {
                    let batting_avg;
                    try {
                        batting_avg = parseFloat(entry[batting_avg_key]);
                        if (isNaN(batting_avg)) batting_avg = 0.0;
                    } catch (e) {
                        batting_avg = 0.0;
                    }
                    
                    let pa;
                    try {
                        pa = parseInt(entry[pa_key], 10);
                        if (isNaN(pa)) pa = 0;
                    } catch (e) {
                        pa = 0;
                    }

                    if (pa >= 30) {
                        const new_entry = {...entry};
                        new_entry[batting_avg_key] = batting_avg;
                        new_entry[pa_key] = pa;
                        filtered_data.push(new_entry);
                    }
                }
                
                const sorted_data = filtered_data.sort((a, b) => {
                    if (b[batting_avg_key] !== a[batting_avg_key]) {
                        return b[batting_avg_key] - a[batting_avg_key];
                    }
                    return b[pa_key] - a[pa_key];
                });

                let html_rows = "";
                let rank = 0;
                let last_score = -1;
                sorted_data.slice(0, 10).forEach((player, index) => {
                    if (player[batting_avg_key] !== last_score) {
                        rank = index + 1;
                    }
                    let rank_display = rank;
                    if (rank === 1) {
                        rank_display = 'ğŸ†';
                    }

                    const is_first = rank === 1;
                    const style = is_first ? ' style="color: red;"' : '';

                    html_rows += `
                        <tr>
                            <td>${rank_display}</td>
                            <td><span${style}>${player[player_key]}</span></td>
                            <td><span${style}>${player[team_key]}</span></td>
                            <td><span${style}>${player[batting_avg_key].toFixed(3)}</span></td>
                        </tr>
                    `;
                    last_score = player[batting_avg_key];
                });
                tbody.innerHTML = html_rows;

            } catch (error) {
                console.error("Error fetching or parsing CSV:", error);
                tbody.innerHTML = `<tr><td colspan="4">è¼‰å…¥è³‡æ–™å¤±æ•—: ${error.message}</td></tr>`;
            }
        }

        fetchAndRenderLeaderboard();
        setInterval(fetchAndRenderLeaderboard, 300000); // Refresh every 5 minutes
    </script>

</body>
</html>
