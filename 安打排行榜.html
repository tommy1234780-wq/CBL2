<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®‰æ‰“æ’è¡Œæ¦œ</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #dddddd;
            text-align: left;
            padding: 8px;
        }
        th {
            background-color: #f2f2f2;
        }

        @media screen and (max-width: 600px) {
            .table-container {
                overflow-x: auto;
            }
            body {
                font-size: 0.9em;
            }
            th, td {
                padding: 6px;
            }
        }
    </style>
</head>
<body>

    <h1>å®‰æ‰“æ’è¡Œæ¦œ <span style="font-size: 0.5em;">(å¦‚å®‰æ‰“æ•¸ç›¸åŒï¼Œæ‰“æ“Šç‡é«˜è€…æ’åè¼ƒå‰)</span></h1>

    <div class="table-container">
        <table>
        <thead>
            <tr>
                <th>æ’å</th>
                <th>çƒå“¡</th>
                <th>éšŠä¼</th>
                <th>å®‰æ‰“</th>
            </tr>
        </thead>
        <tbody id="leaderboard-tbody">
            <!-- Data will be loaded dynamically -->
        </tbody>
    </table>
    </div>

    <script>
        const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vT_X5jYPR24dk5oqUSr1py8glTu-jHZJwuzhyJN7RrjMkgkXjwv0hVgmn7KlieQy_-CZEn6UQofqTbz/pub?gid=546432089&single=true&output=csv";
        const tbody = document.getElementById('leaderboard-tbody');

        async function fetchAndRenderLeaderboard() {
            try {
                const res = await fetch(CSV_URL);
                if (!res.ok) throw new Error('Failed to fetch CSV: HTTP ' + res.status);
                const text = await res.text();
                
                const lines = text.trim().split(/\n/);
                const headers = lines[0].split(',').map(h => h.trim());
                let data = lines.slice(1).map(line => {
                    const values = [];
                    let current_value = "";
                    let in_quotes = false;
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        const next_char = line[i+1];
                        if (char === '"' && in_quotes && next_char === '"' ) {
                            current_value += '"' ;
                            i++;
                        } else if (char === '"' ) {
                            in_quotes = !in_quotes;
                        } else if (char === ',' && !in_quotes) {
                            values.push(current_value.trim());
                            current_value = "";
                        } else {
                            current_value += char;
                        }
                    }
                    values.push(current_value.trim());

                    const row_data = {};
                    headers.forEach((h, i) => row_data[h] = values[i] || "");
                    return row_data;
                });

                const seasonKey = headers.find(h => h.includes('å±†æ•¸') || h.includes('å±†åˆ¥') || h.includes('è³½å­£')) || "å±†æ•¸";
                data = data.filter(row => row[seasonKey] === 'ç¬¬äºŒå±†');

                const player_key = headers.find(h => h.includes('å§“å')) || 'èƒŒè™Ÿ/å§“å';
                const team_key = headers.find(h => h.includes('éšŠä¼')) || 'éšŠä¼';
                const hits_key = headers.find(h => h.includes('å®‰æ‰“ç¸½æ•¸')) || 'å®‰æ‰“ç¸½æ•¸'; // Key for Hits
                const batting_avg_key = headers.find(h => h.includes('æ‰“æ“Šç‡')) || 'æ‰“æ“Šç‡';

                data.forEach(entry => {
                    entry[hits_key] = parseInt(entry[hits_key], 10) || 0;
                    entry[batting_avg_key] = parseFloat(entry[batting_avg_key]) || 0;
                });

                const sorted_data = data
                    .filter(entry => entry[hits_key] > 0)
                    .sort((a, b) => {
                        if (b[hits_key] !== a[hits_key]) {
                            return b[hits_key] - a[hits_key];
                        }
                        return b[batting_avg_key] - a[batting_avg_key];
                    });

                let html_rows = "";
                let rank = 0;
                let last_hits = -1;
                let last_avg = -1;
                sorted_data.slice(0, 10).forEach((player, index) => {
                    if (player[hits_key] !== last_hits || player[batting_avg_key] !== last_avg) {
                        rank = index + 1;
                    }
                    let rank_display = rank;
                    if (rank === 1) {
                        rank_display = 'ğŸ†';
                    }

                    const is_first = rank === 1;
                    const style = is_first ? ' style="color: red;"' : '';

                    html_rows += `
                        <tr>
                            <td>${rank_display}</td>
                            <td><span${style}>${player[player_key]}</span></td>
                            <td><span${style}>${player[team_key]}</span></td>
                            <td><span${style}>${player[hits_key]}</span></td>
                        </tr>
                    `;
                    last_hits = player[hits_key];
                    last_avg = player[batting_avg_key];
                });
                tbody.innerHTML = html_rows;

            } catch (error) {
                console.error("Error fetching or parsing CSV:", error);
                tbody.innerHTML = `<tr><td colspan="4">è¼‰å…¥è³‡æ–™å¤±æ•—: ${error.message}</td></tr>`;
            }
        }

        fetchAndRenderLeaderboard();
        setInterval(fetchAndRenderLeaderboard, 300000); // Refresh every 5 minutes
    </script>

</body>
</html>
