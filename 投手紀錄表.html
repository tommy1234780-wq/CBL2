<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>æŠ•æ‰‹æˆç¸¾æŸ¥è©¢</title>
  <style>
    body { font-family: system-ui, "Noto Sans TC", Arial; margin: 24px; background-color: #f0f2f5; }
    .container { max-width: 1200px; margin: 0 auto; padding: 20px; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    h1 { margin: 0 0 16px; font-size: 28px; color: #333; }
    .note-readonly {
      background-color: #fff3cd;
      color: #856404;
      border: 1px solid #ffeeba;
      padding: 12px 16px;
      margin-bottom: 16px;
      border-radius: 4px;
      font-size: 14px;
    }
    .controls { display: flex; gap: 12px; flex-wrap: wrap; margin-bottom: 16px; }
    input, select, button { padding: 10px 12px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px; }
    button { background-color: #f0f0f0; cursor: pointer; }
    button:hover { background-color: #e0e0e0; }
    .table-wrapper { overflow: auto; max-height: 65vh; border-top: 1px solid #eee; }
    table { width: 100%; border-collapse: collapse; font-size: 14px; }
    th, td { padding: 10px 12px; border-bottom: 1px solid #ddd; text-align: center; white-space: nowrap; }
    /* Combined thead rules for clarity. */
    thead { position: sticky; top: 0; z-index: 2; background: #f9f9f9; }
    th { background: #f9f9f9; }
    thead.is-sticky {
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: box-shadow 0.2s ease-in-out;
    }

    th:nth-child(1), td:nth-child(1) {
      position: sticky;
      left: 0;
      z-index: 1;
      border-right: 1px solid #ddd;
    }

    th:nth-child(2), td:nth-child(2) {
      position: sticky;
      z-index: 1;
      border-right: 1px solid #ddd;
      /* 'left' is set by JS */
    }

    th:nth-child(3), td:nth-child(3) {
      position: sticky;
      z-index: 1;
      border-right: 1px solid #ddd;
      /* 'left' is set by JS */
    }

    /* Set backgrounds for sticky columns */
    td:nth-child(1), td:nth-child(2), td:nth-child(3) { background-color: #fff; }
    thead th:nth-child(1), thead th:nth-child(2), thead th:nth-child(3) { background-color: #f9f9f9; z-index: 3; }

    .career-view-table {
      background-color: #e6f7ff; /* Light blue for career view */
    }

    @media (max-width: 768px) {
      body { margin: 0; background-color: #fff; }
      .container { padding: 15px; border-radius: 0; box-shadow: none; }
      h1 { font-size: 22px; }
      .controls { flex-direction: column; }
      input, select, button { width: 100%; box-sizing: border-box; }
    }
  </style>
</head>
<body>

<div class="container">
  <h1>å°ä¸­å¸‚ CBL ä¼æ¥­äº¤æµè¯ç›Ÿ æŠ•æ‰‹æˆç¸¾æŸ¥è©¢</h1>

  <p style="font-size: 14px; color: #666; margin-bottom: 16px;">æˆç¸¾æ›´æ–°æ™‚é–“ï¼š<span id="last-updated">è®€å–ä¸­...</span></p>

  <div class="note-readonly">
    âš ï¸ æç¤ºï¼šæ­¤é é¢åƒ…ä¾›æŸ¥è©¢æŠ•æ‰‹æˆç¸¾ï¼Œä½¿ç”¨è€…ç„¡æ³•ä¿®æ”¹è³‡æ–™ã€‚
  </div>

  <div class="controls">
    <input id="search" type="text" placeholder="æœå°‹ï¼šçƒå“¡å§“å" />
    <select id="team"><option value="">å…¨éƒ¨çƒéšŠ</option></select>
    <select id="season"><option value="">å…¨éƒ¨å±†æ•¸</option></select>
    <button id="toggle-career-view">æŸ¥çœ‹ç”Ÿæ¶¯æˆç¸¾</button>
  </div>

  <div class="table-wrapper">
    <table id="table">
      <thead><tr id="header-row"></tr></thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>
</div>

  <script>
    // ğŸ‘‡ æŠ•æ‰‹ç´€éŒ„çš„ Google è©¦ç®—è¡¨ CSV é€£çµ
    const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTmnSzqJij7qN0DkHrUHSTUbQv609l1OkQU-1BlZqO2t2Jry0zvcMyQa1DpbGKYSXtF94pg2CU-I3X8/pub?gid=1969750057&single=true&output=csv";

    const searchInput = document.getElementById('search');
    const teamSelect = document.getElementById('team');
    const seasonSelect = document.getElementById('season');
    const headerRow = document.getElementById('header-row');
    const tbody = document.getElementById('tbody');
    const careerViewBtn = document.getElementById('toggle-career-view');
    
    let originalRows = [], careerStats = [], headers = [];
    let isCareerView = false;
    let sortKey = '', sortOrder = 'none';

    // --- ä¸»è¦è³‡æ–™è™•ç†æµç¨‹ ---
    async function main() {
      try {
        const text = await fetchCSV(CSV_URL);
        parseCSV(text); // -> populates headers and originalRows
        
        extractAndUpdateTime();
        calculateCareerStats();
        
        buildFilters();
        setupEventListeners();
        render();
        
      } catch (err) {
        tbody.innerHTML = `<tr><td colspan="10">${err.message}</td></tr>`;
        console.error('è¨ºæ–·ï¼šmain å‡½å¼åŸ·è¡ŒéŒ¯èª¤:', err);
      }
    }

    async function fetchCSV(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`è®€å–å¤±æ•—ï¼šHTTP ${res.status}`);
      return res.text();
    }

    function parseCSV(text) {
      const lines = text.replace(/\r/g,'').split('\n').filter(l => l.trim() !== '');
      headers = splitCSVLine(lines[0]).map(h => h.trim());
      originalRows = lines.slice(1).map(line => {
        const cells = splitCSVLine(line);
        const obj = {};
        headers.forEach((h, i) => obj[h] = (cells[i] || '').trim());
        return obj;
      });
    }

    // --- å·¥å…·å‡½æ•¸ï¼šè½‰æ› IP æ ¼å¼ ---
    function convertIpToDecimal(ipString) {
      if (!ipString) return 0;
      const parts = String(ipString).split('.');
      const innings = parseInt(parts[0] || 0, 10);
      const outs = parseInt(parts[1] || 0, 10);
      if (outs > 2) return innings + 1; // e.g., 1.3 should be 2.0
      return innings + (outs / 3);
    }
    
    function calculateCareerStats() {
      const nameKey = headers.find(h => h.includes('å§“å')) || "èƒŒè™Ÿ/å§“å";
      const teamKey = headers.find(h => h.includes('éšŠ')) || "éšŠä¼";
      const seasonKey = headers.find(h => h.includes('å±†æ•¸') || h.includes('å±†åˆ¥') || h.includes('è³½å­£')) || "å±†æ•¸";
      const nonStatKeys = [nameKey, teamKey, seasonKey]; 

      const ipKey = headers.find(h => h.includes('IP') || h.includes('æŠ•çƒå±€æ•¸') || h.includes('å±€æ•¸')) || 'IP';
      const playerStats = new Map();

      for (const row of originalRows) {
        const playerName = row[nameKey] ? row[nameKey].trim() : null;
        if (!playerName) continue;

        if (!playerStats.has(playerName)) {
          const newStats = {
            [nameKey]: playerName,
            [teamKey]: row[teamKey], 
            [seasonKey]: 'ç”Ÿæ¶¯',
            lastSeason: row[seasonKey],
          };
          for (const h of headers) {
            if (!nonStatKeys.includes(h)) {
                if (h === ipKey) {
                    newStats[h] = convertIpToDecimal(row[h]);
                } else {
                    newStats[h] = (Number(row[h]) || 0);
                }
            }
          }
          playerStats.set(playerName, newStats);
        } else {
          const stats = playerStats.get(playerName);
          
          if (row[seasonKey] > stats.lastSeason) {
            stats.lastSeason = row[seasonKey];
            stats[teamKey] = row[teamKey];
          }

          for (const h of headers) {
            if (!nonStatKeys.includes(h)) {
                if (h === ipKey) {
                    stats[h] += convertIpToDecimal(row[h]);
                } else {
                    stats[h] += (Number(row[h]) || 0);
                }
            }
          }
        }
      }

      const erKey = headers.find(h => h.includes('ER') || h.includes('è‡ªè²¬åˆ†')) || 'ER';
      // *** MODIFIED hKey to be precise for 'è¢«å®‰æ‰“ç¸½æ•¸' ***
      const hKey = headers.find(h => h === 'H' || h.includes('è¢«å®‰æ‰“ç¸½æ•¸')) || 'H';
      const bbKey = headers.find(h => h.includes('BB') || h.includes('å››å£') || h.includes('ä¿é€')) || 'BB';
      const hbpKey = headers.find(h => h.includes('HBP') || h.includes('è§¸èº«')) || 'HBP'; // Already correct
      
      const eraKey = headers.find(h => h.includes('ERA') || h.includes('é˜²ç¦¦ç‡')) || 'ERA';
      const whipKey = headers.find(h => h.includes('WHIP')) || 'WHIP';

      // --- é‡æ–°è¨ˆç®—ä¸¦å¼·åˆ¶è¦†è“‹æ¯”ç‡æ•¸æ“š ---
      careerStats = Array.from(playerStats.values()).map(stats => {
        const totalIP = stats[ipKey] || 0;
        const totalER = stats[erKey] || 0;
        const totalH = stats[hKey] || 0;
        const totalBB = stats[bbKey] || 0;
        const totalHBP = stats[hbpKey] || 0;
        
        // å°‡ç´¯åŠ çš„å°æ•¸ IP è½‰å› x.1, x.2 çš„æ ¼å¼
        const fullInnings = Math.floor(totalIP);
        const outs = Math.round((totalIP - fullInnings) * 3);
        stats[ipKey] = `${fullInnings}.${outs}`;

        const calculatedERA = totalIP > 0 ? ((totalER / totalIP) * 9) : 0;
        stats[eraKey] = calculatedERA.toFixed(2);

        // --- åµéŒ¯æ—¥èªŒ (ERA) ---
        console.log(
            `[é˜²ç¦¦ç‡è¨ˆç®—åµéŒ¯] çƒå“¡: ${stats[nameKey]}, ` +
            `ç¸½è‡ªè²¬åˆ† (totalER): ${totalER}, ` +
            `ç¸½æŠ•çƒå±€æ•¸ (totalIP): ${totalIP > 0 ? totalIP.toFixed(3) : 0}, ` +
            `è¨ˆç®—å…¬å¼: (${totalER} / ${totalIP > 0 ? totalIP.toFixed(3) : 0}) * 9, ` +
            `è¨ˆç®—çµæœ (ERA): ${stats[eraKey]}`
        );
        // --- åµéŒ¯æ—¥èªŒçµæŸ (ERA) ---

        // WHIP calculation
        const calculatedWHIP = totalIP > 0 ? ((totalH + totalBB + totalHBP) / totalIP) : 0;
        stats[whipKey] = calculatedWHIP.toFixed(2);

        // --- åµéŒ¯æ—¥èªŒ (WHIP) ---
        console.log(
            `[WHIPè¨ˆç®—åµéŒ¯] çƒå“¡: ${stats[nameKey]}, ` +
            `ç¸½è¢«å®‰æ‰“ (totalH): ${totalH}, ` +
            `ç¸½å››å£ (totalBB): ${totalBB}, ` +
            `ç¸½è§¸èº« (totalHBP): ${totalHBP}, ` +
            `ç¸½æŠ•çƒå±€æ•¸ (totalIP): ${totalIP > 0 ? totalIP.toFixed(3) : 0}, ` +
            `è¨ˆç®—å…¬å¼: ((${totalH} + ${totalBB} + ${totalHBP}) / ${totalIP > 0 ? totalIP.toFixed(3) : 0}), ` +
            `è¨ˆç®—çµæœ (WHIP): ${stats[whipKey]}`
        );
        // --- åµéŒ¯æ—¥èªŒçµæŸ (WHIP) ---
        
        return stats;
      });
    }

    function render() {
      const dataToRender = isCareerView ? careerStats : originalRows;
      
      const nameKey = searchInput.dataset.nameKey;
      const teamKey = teamSelect.dataset.teamKey;
      const seasonKey = seasonSelect.dataset.seasonKey;
      
      const kw = searchInput.value.trim().toLowerCase();
      const team = teamSelect.value;
      const season = seasonSelect.value;
      
      const filtered = dataToRender.filter(r => {
        const passName = kw ? String(r[nameKey] || '').toLowerCase().includes(kw) : true;
        const passTeam = team ? r[teamKey] === team : true;
        const passSeason = isCareerView ? true : (season ? r[seasonKey] === season : true);
        return passName && passTeam && passSeason;
      });

      if (sortKey && sortOrder !== 'none') {
        const isNumeric = !['ERA', 'WHIP'].includes(sortKey) && headers.includes(sortKey);
        filtered.sort((a, b) => {
          let valA, valB;
          if (sortKey.includes('IP')) {
            valA = convertIpToDecimal(a[sortKey]);
            valB = convertIpToDecimal(b[sortKey]);
          } else {
             valA = isNumeric ? Number(a[sortKey] || 0) : parseFloat(a[sortKey] || 0);
             valB = isNumeric ? Number(b[sortKey] || 0) : parseFloat(b[sortKey] || 0);
          }
          if (isNaN(valA)) return 1;
          if (isNaN(valB)) return -1;
          // ERA, WHIP å‡åºï¼Œå…¶ä»–é™åº
          const defaultAsc = ['ERA', 'WHIP'].includes(sortKey);
          if (sortOrder === 'asc') return defaultAsc ? valA - valB : valA - valB;
          return defaultAsc ? valB - valA : valB - valA;
        });
      }

      renderHeaders();
      renderBody(filtered);
      
      updateStickyColumns();
    }
    
    function renderHeaders() {
      const UPDATE_TIME_COLUMN_INDEX = 26; // AA1 æ¬„ä½
      const seasonKey = headers.find(h => h.includes('å±†æ•¸') || h.includes('å±†åˆ¥') || h.includes('è³½å­£'));
      
      window.displayHeaders = headers.filter((h, index) => {
        if (index === UPDATE_TIME_COLUMN_INDEX) return false;
        return true;
      });

      headerRow.innerHTML = window.displayHeaders.map(h => {
        const isSortable = originalRows.length > 0 && (Number(originalRows[0][h]) >= 0 || ['ERA', 'WHIP', 'IP'].includes(h));
        if (!isSortable || h === 'èƒŒè™Ÿ/å§“å') return `<th>${h}</th>`;
        
        let sortIndicator = '&#9670;';
        if (sortKey === h) {
          sortIndicator = sortOrder === 'asc' ? '&#9650;' : '&#9660;';
        }
        return `<th>${h} <span class="sort-toggle" data-key="${h}" style="cursor: pointer;">${sortIndicator}</span></th>`;
      }).join('');
    }

    function renderBody(data) {
       tbody.innerHTML = data.map(r => `<tr>` + window.displayHeaders.map(h => `<td>${r[h] ?? ''}</td>`).join('') + `</tr>`).join('')
        || `<tr><td colspan="${(window.displayHeaders || []).length}">æ‰¾ä¸åˆ°ç¬¦åˆçš„è³‡æ–™</td></tr>`;
    }

    function setupEventListeners() {
      searchInput.addEventListener('input', render);
      [teamSelect, seasonSelect].forEach(el => el.addEventListener('change', render));
      
      careerViewBtn.addEventListener('click', () => {
        isCareerView = !isCareerView;
        careerViewBtn.textContent = isCareerView ? 'è¿”å›è³½å­£æˆç¸¾' : 'æŸ¥çœ‹ç”Ÿæ¶¯æˆç¸¾';
        seasonSelect.disabled = isCareerView;
        document.getElementById('table').classList.toggle('career-view-table', isCareerView);
        sortKey = '';
        sortOrder = 'none';
        render();
      });

      headerRow.addEventListener('click', e => {
        const target = e.target.closest('.sort-toggle');
        if (!target) return;
        
        const key = target.dataset.key;
        // WHIP å’Œ ERA é è¨­ç‚ºå‡åºï¼Œå…¶ä»–ç‚ºé™åº
        const defaultOrder = ['ERA', 'WHIP'].includes(key) ? 'asc' : 'desc';

        if (sortKey === key) {
          sortOrder = (sortOrder === 'asc' ? 'desc' : 'asc');
        } else {
          sortKey = key;
          sortOrder = defaultOrder;
        }
        render();
      });

      window.addEventListener('resize', updateStickyColumns);
      
      try {
        const thead = document.querySelector('#table thead');
        if (thead) {
          new IntersectionObserver(([e]) => thead.classList.toggle('is-sticky', e.intersectionRatio < 1), { threshold: [1] }).observe(thead);
        }
      } catch (e) {
        console.error('è¨ºæ–·ï¼šSticky header observer failed:', e);
      }
    }

    function buildFilters() {
      const teamKey = headers.find(h => h.includes('éšŠ')) || "éšŠä¼";
      const seasonKey = headers.find(h => h.includes('å±†æ•¸') || h.includes('å±†åˆ¥') || h.includes('è³½å­£')) || "å±†æ•¸";
      const nameKey = headers.find(h => h.includes('å§“å')) || "èƒŒè™Ÿ/å§“å";

      const teams = [...new Set(originalRows.map(r => r[teamKey]).filter(Boolean))].sort();
      const seasons = [...new Set(originalRows.map(r => r[seasonKey]).filter(Boolean))].sort().reverse();
      
      teamSelect.innerHTML = '<option value="">å…¨éƒ¨çƒéšŠ</option>' + teams.map(t => `<option>${t}</option>`).join('');
      seasonSelect.innerHTML = '<option value="">å…¨éƒ¨å±†æ•¸</option>' + seasons.map(s => `<option>${s}</option>`).join('');
      
      // é è¨­é¡¯ç¤ºç¬¬äºŒå±†
      seasonSelect.value = 'ç¬¬äºŒå±†';

      searchInput.dataset.nameKey = nameKey;
      teamSelect.dataset.teamKey = teamKey;
      seasonSelect.dataset.seasonKey = seasonKey;
    }

    function extractAndUpdateTime() {
      const UPDATE_TIME_COLUMN_INDEX = 26; // AA1
      const updateTimeElement = document.getElementById('last-updated');
      if (!updateTimeElement) return;

      if (headers.length > UPDATE_TIME_COLUMN_INDEX) {
        updateTimeElement.textContent = headers[UPDATE_TIME_COLUMN_INDEX] || 'ç„¡æ³•å–å¾—æ›´æ–°æ™‚é–“';
      } else {
        updateTimeElement.textContent = 'CSVè³‡æ–™ä¸è¶³';
      }
    }

    function splitCSVLine(line) {
      const out = []; let cur = '', inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const c = line[i], n = line[i+1];
        if (c === '"' && inQuotes && n === '"') { cur += '"'; i++; }
        else if (c === '"') { inQuotes = !inQuotes; }
        else if (c === ',' && !inQuotes) { out.push(cur); cur = ''; }
        else { cur += c; }
      }
      out.push(cur);
      return out;
    }
    
    function updateStickyColumns() {
      const firstCol = document.querySelector('#table th:nth-child(1)');
      const secondCol = document.querySelector('#table th:nth-child(2)');
      if (!firstCol || !secondCol) return;
      
      const firstColWidth = firstCol.offsetWidth;
      const secondColWidth = secondCol.offsetWidth;

      const secondColElems = document.querySelectorAll('#table th:nth-child(2), #table td:nth-child(2)');
      secondColElems.forEach(elem => {
        elem.style.left = firstColWidth + 'px';
      });

      const thirdColElems = document.querySelectorAll('#table th:nth-child(3), #table td:nth-child(3)');
      thirdColElems.forEach(elem => {
        elem.style.left = (firstColWidth + secondColWidth) + 'px';
      });
    }

    main();
  </script>

</body>
</html>